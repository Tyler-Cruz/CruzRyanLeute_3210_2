<html>
<head>
    <title>CSC3210 CruzRyanLeute_2</title>
</head>
<body>

    <h1> Toggles: Move camera target with 'WASD' keys, Rotations with 'T' and 'R'</h1>
    <canvas id="myCanvas" width="800" height="800"></canvas>

    <script type="module">
import * as THREE from "three";

// variables to control the camera
var xLookAt = 0;
var yLookAt = 0;
var zLookAt = 0;
var turnSpeed = 0.4;
var animateRotation = false;
var animateOtherRotation = false;
var cameraRotation = 0.0;

var mouse = { x: 0, y: 0};

var scene = new THREE.Scene();

var camera = new THREE.PerspectiveCamera( 35, window.innerWidth / window.innerHeight, .1, 3000 );
camera.position.set(0,0,15);   
camera.lookAt( new THREE.Vector3(xLookAt,yLookAt,zLookAt));
scene.add( camera );

// rear view mirror camera
var rearCamera = new THREE.PerspectiveCamera( 35, window.innerWidth / window.innerHeight, .1, 3000 );
rearCamera.position.copy(camera.position); 
rearCamera.rotation.copy(camera.rotation);  
scene.add( rearCamera );


var renderer = new THREE.WebGLRenderer({canvas: document.getElementById('myCanvas')});
renderer.setClearColor(0x000000);
renderer.setPixelRatio(document.getElementById('myCanvas').devicePixelRatio);
// If you want the render to span the window, uncomment this
renderer.setSize(window.innerWidth, window.innerHeight);

document.addEventListener('mousemove', function(event) {
  //normalize mouse x and y positions
  mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
  mouse.y = -(event.clientY / window.innerHeight) * 2 + 1; },
  false);


// Add another sphere
var sphere1 = new THREE.SphereGeometry(0.50, 32, 32);
sphere1.translate(0.2, 0.0, 0.5);
var sphere2 = new THREE.SphereGeometry(0.50, 32, 32);
sphere2.translate(0.0, 0.0, -0.5);
var sphereMaterial = new THREE.MeshLambertMaterial( {color: 0x8888ff} ); 
var sphere1Mesh = new THREE.Mesh( sphere1, sphereMaterial );
scene.add( sphere1Mesh );
var sphereMaterial2 = new THREE.MeshLambertMaterial( {color: 0xff0000} ); 
var sphere2Mesh = new THREE.Mesh( sphere2, sphereMaterial2 );
scene.add( sphere2Mesh );

//creates second type of object to show up
//creates cubes that can appear
const geometry = new THREE.BoxGeometry( 1, 1, 1 ); 
const material = new THREE.MeshBasicMaterial( {color: 0x00ff00} ); 
const cube = new THREE.Mesh( geometry, material ); 
scene.add( cube );
//start of the object pool
class Object{
  //creates the object with x y and z points
  constructor(x, y, z) {
    this.x = x;
    this.y = y;
    this.z = z;
  }

  update() {
    // changes when object in pool is used
  }
}

//makes the 
class ObjectPool {
  constructor(maxSize) {
    this.pool = [];
    this.maxSize = maxSize;
  }

  get() {
    if (this.pool.length > 0) {
      return this.pool.pop();
    } else if (this.pool.length < this.maxSize) {
      return new Object();
    } else {
      return null; // Pool is full
    }
  }

  release(object) {
    this.pool.push(object);
  }
}

// sets the pool at 100 objects
const objPool = new ObjectPool(100);

function createObj() {
  for (let i = 0; i < 50; i++) {
    const obj = objPool.get();

    if (obj) {
      // Initialize object properties
      obj.x = Math.random() * 100;
      obj.y = Math.random() * 100;
      obj.z = Math.random() * 100;

    }
  }
}

function updateObj() {
  // update later 
}

function removeObj(Object) {
  // removes object from pool

  objPool.release(obj);
  objPool.pop(obj);
}

//creating raycaster
raycaster = new THREE.Raycaster();

	renderer.setPixelRatio( window.devicePixelRatio );
  renderer.setSize( window.innerWidth, window.innerHeight );
	renderer.setAnimationLoop( animate );
	document.body.appendChild( renderer.domElement );

document.addEventListener( 'mousemove', onDocumentMouseMove );

const effectController = {
  focalLength: 15,
	focalDepth: 3
};


// Lights
var directionalLight = new THREE.DirectionalLight( 0xffffff, 0.75 );
directionalLight.position.y = 10.0;
scene.add( directionalLight );
var directionalLight2 = new THREE.DirectionalLight( 0xffffff, 0.75 );
directionalLight2.position.y = -10.0;
scene.add( directionalLight2 );

// Use this for not-necessarily-static scenes or scenes you want to animate
function animate() {
  // move the camera forward based on  current direction
  var forwardDirection = new THREE.Vector3();
  camera.getWorldDirection(forwardDirection);  // get the direction camera is facing
  var moveSpeed = 0.1;  
  camera.position.add(forwardDirection.multiplyScalar(moveSpeed)); 

  // update camera look direction based on mouse movement
  var cameraRotationSpeed = 0.002; 
  camera.rotation.y -= mouse.x * cameraRotationSpeed;  // left-right movement
  camera.rotation.x -= mouse.y * cameraRotationSpeed;  // up-down movement

  if( animateRotation ) 
    // The applyAxisAngle method rotates about an axis in space
    camera.position.applyAxisAngle( new THREE.Vector3(0.0, 1.0, 0.0 ), turnSpeed * 0.1 );
  if( animateOtherRotation ) 
    camera.position.applyAxisAngle( new THREE.Vector3(0.0, 0.0, 1.0 ), turnSpeed * 0.1 );

  camera.lookAt( new THREE.Vector3(xLookAt,yLookAt,zLookAt) );
 
  rearCamera.position.copy(camera.position);
  rearCamera.rotation.copy(camera.rotation);
  rearCamera.rotateY(Math.PI);  // rotate view

  // render main view
  renderer.setScissorTest(false);
  renderer.setViewport(0, 0, window.innerWidth, window.innerHeight);
  renderer.render(scene, camera);

  // render rear view
  var rearViewWidth = window.innerWidth * 0.25;
  var rearViewHeight = window.innerHeight * 0.25;
  renderer.setScissorTest(true);
  renderer.setScissor(window.innerWidth - rearViewWidth - 10, window.innerHeight - rearViewHeight - 10, rearViewWidth, rearViewHeight);
  renderer.setViewport(window.innerWidth - rearViewWidth - 10, window.innerHeight - rearViewHeight - 10, rearViewWidth, rearViewHeight);
  renderer.render(scene, rearCamera);
  renderer.render( scene, camera );

  requestAnimationFrame( animate );
}
animate();

function toggleRotation() {
  animateRotation = !animateRotation;
}
function toggleOtherRotation() {
  animateOtherRotation = !animateOtherRotation;
}

//collision of camera:
//check the values of the camera and objects to see if there is an object within a certain distance
//if it hits that value destroy the object and shake camera for ~one second
function collision(){

	// if(camera.position == object.position){

		//removes object collided with
		removeObj();

		//randomly shakes camera when hit
		for(let i = 0; i < 100; i++){
		camera.rotation.y -= Math.random().x * cameraRotation;  
  		camera.rotation.x -= Math.random().y * cameraRotation;  
		}

	//}
}

// Simple way to setup keybaord controls:
function keyHandler(e) {
  switch(e.keyCode){
    case 83: // The 'S' key
      yLookAt -= turnSpeed;
    break;
    case 68: // The 'D' key
      xLookAt += turnSpeed;
    break;
    case 65: // The 'A' key
      xLookAt -= turnSpeed;
    break;
    case 87: // The 'W' key
      yLookAt += turnSpeed;
    break;
    case 84: // The 'T' key
      toggleRotation();
    break;
    case 82: // The 'R' key
      toggleOtherRotation();
    break;
  }
}
document.addEventListener( "keydown", keyHandler, false );
    </script>
</body>
</html>


// THREE.js example with infinite floating cubes edited to use a perspective camera
// instead of cinematic
// Starting with this as a base may be beneficial

<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgl - camera perspective</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="main.css">
		<style>
			body {
				background-color: #fff;
				color: #000;
			}
			a {
				color: #08f;
			}
		</style>
	</head>
	<body>

		<div id="info">
			<a href="https://threejs.org" target="_blank" rel="noopener">three.js</a> webgl - interactive cubes
		</div>

		<script type="importmap">
			{
				"imports": {
					"three": "../build/three.module.js",
					"three/addons/": "./jsm/"
				}
			}
		</script>

		<script type="module">

			import * as THREE from 'three';

			import Stats from 'three/addons/libs/stats.module.js';
			//import { GUI } from 'three/addons/libs/lil-gui.module.min.js';

			let camera, scene, raycaster, renderer, stats;

			const mouse = new THREE.Vector2();
			let INTERSECTED;
			const radius = 100;
			let theta = 0;

			init();

			function init() {

				// Create a PerspectiveCamera with similar settings
				camera = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, 1, 1000 );
				camera.position.set( 2, 1, 500 );

				scene = new THREE.Scene();
				scene.background = new THREE.Color( 0xf0f0f0 );

				scene.add( new THREE.AmbientLight( 0xffffff ) );

				const light = new THREE.DirectionalLight( 0xffffff );
				light.position.set( 1, 1, 1 ).normalize();
				scene.add( light );

				const geometry = new THREE.BoxGeometry( 20, 20, 20 );

				for ( let i = 0; i < 1500; i ++ ) {

					const object = new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { color: Math.random() * 0xffffff } ) );

					object.position.x = Math.random() * 800 - 400;
					object.position.y = Math.random() * 800 - 400;
					object.position.z = Math.random() * 800 - 400;

					scene.add( object );

				}

				raycaster = new THREE.Raycaster();

				renderer = new THREE.WebGLRenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.setAnimationLoop( animate );
				document.body.appendChild( renderer.domElement );

				stats = new Stats();
				document.body.appendChild( stats.dom );

				document.addEventListener( 'mousemove', onDocumentMouseMove );

				window.addEventListener( 'resize', onWindowResize );

				// Effect controller to simulate camera behavior
				const effectController = {
					focalLength: 15,
					focalDepth: 3
				};
			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			function onDocumentMouseMove( event ) {

				event.preventDefault();

				mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
				mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;

			}

			function animate() {

				render();
				stats.update();

			}

			function render() {

				// slowly moves camera so that user traverses through gemoetries
				camera.position.x -= 0.1;
				camera.position.y -=0.1;
				camera.position.z -= 0.1;
				camera.lookAt(scene.position);

				camera.updateMatrixWorld();

				// find intersections
				raycaster.setFromCamera( mouse, camera );

				const intersects = raycaster.intersectObjects( scene.children, false );

				if ( intersects.length > 0 ) {

					if ( INTERSECTED != intersects[ 0 ].object ) {

						if ( INTERSECTED ) INTERSECTED.material.emissive.setHex( INTERSECTED.currentHex );

						INTERSECTED = intersects[ 0 ].object;
						INTERSECTED.currentHex = INTERSECTED.material.emissive.getHex();
						INTERSECTED.material.emissive.setHex( 0xff0000 );

					}

				} else {

					if ( INTERSECTED ) INTERSECTED.material.emissive.setHex( INTERSECTED.currentHex );

					INTERSECTED = null;

				}

				renderer.clear();
				renderer.render( scene, camera );


			    // adding rearview mirror view in top right corner	

				renderer.setScissorTest(false);
  				renderer.setViewport(0, 0, window.innerWidth, window.innerHeight);
  				renderer.render(scene, camera);

 				
				 var rearViewWidth = window.innerWidth * 0.25;
				 var rearViewHeight = window.innerHeight * 0.25;
				 renderer.setScissorTest(true);
				 renderer.setScissor(window.innerWidth - rearViewWidth - 10, window.innerHeight - rearViewHeight - 10, rearViewWidth, rearViewHeight);
				 renderer.setViewport(window.innerWidth - rearViewWidth - 10, window.innerHeight - rearViewHeight - 10, rearViewWidth, rearViewHeight);
				 renderer.render( scene, camera );

				}

		</script>

	</body>
</html>

